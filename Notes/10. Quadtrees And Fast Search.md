---
type: topic
academic_year: 2
subject_code: CSCI203
subject_name: Algorithms And Data Structures
topic_number: 10
title: Quadtrees And Fast Search
cssclass: flatBlue, wideTable
---
< [[__CSCI203 MOC.md|Return to CSCI203 MOC]]
## Quadtrees
+ Applications of Geometrid/Spatial Data Structures
	+ Computer graphics, games. Movies
		+ Mesh generation
		+ Collision detection in 2D.
	+ Computer Vision, CAD, street maps (Google maps / Google Earth)
		+ Image representation and processing
	+ Human-Computer Interface Design
	+ Virtual Reality
	+ Visualisation (graphing complex functions)
---start-multi-column
+ Most often used to partition a 2D space

--- end-column ---

![500](10.Quadtrees_partition2D_Space.png)

--- end-multi-column
--- start-multi-column

+ Each internal node (including the root) has <span style=color:red>exactly</span> four children.
	+ 4-way tree

--- end-column ---
![500](10.Quadtrees_internalNode_FourChildren.png)
--- end-multi-column
+ Data associated with leaf node represents "interesting" information.
--- start-multi-column

![500](10.Quadtrees_interestingInformation.png)

--- end-column ---

![500](Quadtrees_Interesting_Blank.png)

--- end-multi-column
### Quadtree in Actions
+ What is the closest restaurant to my hotel.
![|500](10.QuadtreesAction_closestRestaurentHotel.png)
+ Find the 4 closest restaurants to my hotel
![500](10.QuadtreesAction_4closestRestaurentsHotel.png)

### Types of Quadtrees
+ Region Quadtrees
	+ Recursive subdivisions into squares
	+ Data stored in a leaf node is information about the space of the cell it represents.
	+ Often used in image processes
![500](10.TypeQuadtrees_RegionQuadtrees.png)
![500](10.TypeQuadtrees_RegionQuadtrees1.png)
+ Point and Point-Region Quadtrees
	+ Similar quadtrees
	+ PR quadtrees store a list of points that exist within the cell of a leaf, rather than values applied to an entire area of the cell of a leaf in a region quadtree.
![500](10.PointPoint-RegionQuadtrees_ParticalSimulation.png)
![500](10.Point_Point-RegionQuadtrees_typesOfNodes.png)
Three types of nodes are used in PR quadtree:
+ **Point node:** Used to represent of a point. Is always a leaf node.
+ **Empty node:** Used as a leaf node to represent that no point exists in the region it represent.
+ **Region node:** This is always an internal node. It is used to represent a region. A region node always have 4 children nodes that can be a point node or empty node.
## Point-Region Quadtrees - Operations
+ Construction from a 2D area
1. Divide the current two dimensional space into four regions
2. If a region contains one or more points in it,
	1. Create a child object, storing in it the 2-dimensional space of the region
3. If a region does not contain any points,
	1. Do not create a child for it.
4. Continue to perform recursion for each of the children.
+ Insertion
	1. Start with root node as current node.
	2. If the given point is not in boundary represented by current node, stop insertion with error.
	3. Determine the appropriate child node to store the point.
	4. If the child node is empty node, replace it with a point node representing the point. Stop insertion.
	5. If the child node is a point node, replace it with a region node. Call insert for the point that just got replaced. Set current node as the newly formed region node.
	6. If selected child node is a region node, set the child node as current node. Recursively call insertion.
+ Search
1. Start with root node as current node.
2. If the given point is not in boundary represented by current node, stop search with error.
3. Determine the appropriate child node to search the point.
4. If the child node is empty node, return FALSE.
5. If the child node is a point node and it matches  the given point return TRUE, otherwise return FALSE.
6. If the child node is a region node, set current node as the child region node. Recursively call search.
## Quadtrees - Complexity
+ Time Complexity:
	+ Find: $O(\text{log N})$
	+ Insert: $O(\text{log N})$
	+ Search: $O(\text{log N})$
+ Space complexity:
	+ $O(\text{k log N})$ 
	+ Where k is count of points in the space and space is of dimension $N\times M,N\ge M$
## Faster Searching
+ Say we have a set of data consisting of pairs:
	+ E.g. Name and Telephone Number.
+ How do we find the number associated with a given name?
	+ What is the best data structure to use?
	+ Assume that there are $n$ pairs of data.
+ Linear list:
	+ Look at every entry.
	+ $O(n)$
+ BST:
	+ Traverse the tree from the root.
	+ $O(\text{log n})$, $O(n)$ worst case so use a balanced tree.
### Even faster?
+ Can we do better than $O(\text{log n})$
+ How about $O(1)$
	+ Constant time searching.
+ To do this we use a dictionary:
	+ Map; Hash Table
+ This is a data structure that allows you to determine:
	+ Whether a key is present;
	+ If a key is present what its associated data is.
### Constant Time Search $O(1)$
+ Use a Dictionary:
	+ Map + Hash Table.
+ This is a data structure that allows you to determine:
	+ Whether a key is present;
	+ If a key is present what its associated data is.
## Operations on Dictionaries
+ Given a dictionary $D$, with contents consisting of pairs of the form $<\text{ key: value}>$, we require the following operations to be defined.
	+ Insert: `D[key] = value`
	+ Delete: `delete(D[key])`
	+ Search: `value = D[key], value == nil` if key has not been stored.
+ Note that the dictionary behaves like an array with non-integer index.
### Ubitquity
+ Dictionaries form a part of every modern computer language:
	+ C++:
		+ `std::map< key_type, value_type > dictionary_name;`
	+ Java:
		+ `Map dictionary_name = new Hashtable();`
		+ `Map dicitonary_name = new HashMap();`
		+ `Map dictionary_name = new LinkedHashMap();`
	+ Python:
		+ Dictionary data type - created by reference.
		+ E.g. `en_fr = {"red": "rouge", "green" : "vert", "blue" : "bleu", "yellow" : "jaune"}`
### Motivation
+ Dictionaries are used in many applications:
	+ Databases: Fast access to record given key.
	+ Compilers: Maintenance of symbol table.
	+ Network routers: Looking up IP address
	+ String matching: Genetic analysis
	+ Security: Password checking.
## Implementation
+ There are several ways to implement the dictionary data type:
	+ Let us start with the simplest (and, in most cases, worst) approach:
		+ The Direct Access Table:
### The Direct Access Table
+ This is a simply a big array where the index of the array is the key and the contents of the array is the value.
--- start-multi-column

+ Only works if keys are integers.
	+ E.g. key = phone number, value = name
+ So, should we use it in this case?
	+ Typical phone number: +64 2 4221 4033
	+ 11 digits - one hundred billion possible entries.
	+ 20 characters per name.
	+ 2TB of storage. 
		+ For 100, 000, 000, 000
+ If $U$ is the universe of keys $n=|\ U\ |$.

--- end-column ---

![300](10.DirectAccessTable_Array.png)

--- end-multi-column
--- start-multi-column

+ Operations:
	+ `Search (T, K) {return T[k]}`
	+ `Insert (T, x) {T[key[x]] <- x}`
	+ `Delete (T, x) {T[key[x]] <- nil }`
	+ All in $O(1)$

--- end-column ---
![500](10.Implementation_Operations.png)

--- end-multi-column
+ Problems - when $U$ is large.
	+ Keys must be non-negative integers
	+ The set $K$ of keys actually stored is small. Much space is wasted.
### Fixing the Problems
+ Problem 1: Keys must be (non-negative) integers.
+ Solution: define a function `prehash(key): integer`
	+ This function, when given a key of whatever type we need to store returns a non-negative integer value.
	+ So `D[key] = value` becomes `T[prehash(key)] = value`
		+ $T$ is the direct access table we are using to implement the dictionary, $D$.
+ Hold on!
	+ That was too easy!
	+ What exactly does `prehash()` do?
### Implementing $\text{prehash()}$
+ In theory:
	+ Every piece of data in a computer is a sequence of bits.
	+ Every sequence of bits can be interpreted as a non-negative integer.
	+ Problem solved! Really?
	+ Consider 8-character keys: 8 characters = 64 bits.
	+ Does this mean we need an array with $2^{64}$ entries?
+ In Practice:
	+ There are many different possible $\text{prehash}$ functions.
+ Ideally:
	+ $\text{prehash(x)} = \text{prehash(y) iff }x=y$
	+ This is not usually always true, sometimes two different keys may have the same $prehash$ value.
	+ For the sake of simplicity we will assume that the above relationship holds.
### Fixing the Problems
+ Problem 2:
	+ Direct access tables are huge!
		+ Phone numbers: $-10^{11}$ records.
		+ 8-letter words: $-2^{64}$ records.
	+ Clearly this a $\text{BAD THING}^{TM}$
	+ The problem here is the size of the universe of possible keys $|\ U\ |$.
+ Solution: Hashing.
	+ Reduce the (huge) universe of all possible keys down to a manageable size, $m$.
	+ Our table will be of size $m$.
	+ We have a function h so that $0\le\text{h(key)}\lt m$ for all valid keys.