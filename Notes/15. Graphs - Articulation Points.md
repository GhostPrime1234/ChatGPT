---
type: topic
academic_year: 2
subject_code: CSCI203
subject_name: Algorithms And Data Structures
topic_number: 15
title: Graphs - Articulation Points
cssclass: flatBlue, wideTable
---
< [[__CSCI203 MOC.md|Return to CSCI203 MOC]]
## Recall - `DFS_ALL(G)`
+ Uses a <span style=color:red>global timestamp <i>time</i></span>
```pseudocode
DFS_ALL(G)
	FOR EACH u ∈ V
		do color[u] <- WHITE
	END FOR
time <- 0
for each u ∈ V
	do if color[u] = WHITE then DFS-VISIT(u)
DFS-VISIT(G,u)
color[u] <- GRAY  // discover u
time <- time + 1
d[u] <- time
for each v ∈ Adj[u]  // explore (u, v)
	do if color[v] = WHITE then DFS-VISIT(v)
color[u] <- BLACK  
time <- time + 1
f[u] <- time     // finish u
```
## Edge Classification
+ If we perform a DFS on a graph we can classify the edges of a graph:
	+ `Tree edges`: these form part of the search tree (or forest)
	+ `Forward edges`: these lead from a vertex to a descendant
	+ `Backward edges`: these lead from a vertex to an ancestor
	+ `Cross edges`: these are all the edges that are left - they connect unrelated vertices.
+ Vertex *v* is descendent of vertex *u* in depth-first search if and only if *v* is discovered during the time which *u* is grey.
![](15.EdgeClassification_Graphs.png)
### Undirected Graphs
+ For an undirected graph, it can only has tree edges or back edges.
+ Tree edges: Which are the edges $\{p[v],v\}$ where DFS calls are mad.
+ Back edges: which are the edges $\{u,\}$ where $v$ is an ancestor of $u$ in the DFS tree
## Another Example
+ Given a graph $G=(V,E)$, it traverses all vertices of $G$ and constructs a forest (a collection of rooted trees), together with a set of source vertices (the roots).
![500](15.EdgeClassification_Graph2.png)\
## `DFS_ALL(G)` - a Simple Version
```pseudocode
DFS{G} 
	for each v in V do // Initialise
		visit[v] = false
		p[v] = None
		time = 0
	end for
	for each v in V do
		if (visit[v] == False): RDFS(v)
	end for
end procedure
RDFS(v)
	visit[v] = true
	d[v] += time
	for each w in Adj(v) do
		if (visit[w] == False) then
			p[w] = v
			RDFS(w)
		end if
	end for
```
+ $d[u]$ - the discovery time, a counter indicating when vertex u is discovered
+ $p[u]$ - the predecessor of $u$, which discovered $u$.
![](15.DFS_ALL_Diagram.png)
## Connected Components in a Graph
+ A connected component is a **maximal connected subgraph of an undirected graph**. Each vertex belongs to exactly to one connected component, as does one edge.
+ A graph is connected if it has exactly one connected component.
![](ConnectedComponentsGraph_Graphs.png)
## Articulation Points
+ A vertex, $v$ in an undirected connected graph is an articulation point (or cut vertex) if removing it (and edges through it) disconnects the graph.
+ Articulation points represent vulnerabilities in a connected network - single points whose failure would split the network into 2 or more disconnected components.
+ They are useful for designing reliable networks.
+ For a `disconnected` undirected graph, an articulation point is a is a vertex removing which increases number of connected components
+ Conduct a depth first traversal of G, producing the spanning tree T with $discovery[v]$ and $Low[v]$ for each node $v$
+ Consider each node v of the graph:
	+ The root of the DFS tree, $T$, is an articulation point if it has two or more children.
	+ If $v$ has no children in $T$, it is not an articulation point
	+ Any other $internal$ (non-leaf) vertex $v$ in the DFS tree is an articulation point if $v$ has a non-leave child $w$ such that $Low[w]\ge discovery[v]$.
```pseudocode
// search for the DFS tree T
procedure ArticulationPoints 
	for each v in V do
		articulation_point(v) = False
		if (p[v] == None) then
			if (|Adj(v)|>1) then
				articulation_point(v) = 
			else then
				for each w in Adj(v) and w is not a leaf in T do
					if (Low[w] >= discover[v]) then
						articulation_point(v) = True
				end for
			end if
		end if
	end for
end ArticulationPoints
```
+ Which vertices are articulation points?
![500](15.AriculationPoints_Vertices.png)
+ How can we find articulation points in a systematic manner?
### A Naïve Approach
+ A simple approach is to one by one remove all vertices and see if removal of a vertex causes disconnected graph. Following are steps of simple approach for connected graph.
+ For every vertex $v$, do the following:
	+ Remove $v$ from the graph
	+ See if the graph remains connected (We can either use BFS or DFS)
	+ Add $v$ back to the graph.
+ Time complexity $O(V\times (V+E))$
+ Can we do better?
### Observations
1. The root of the DFS tree is an articulation if it has two or more children.
2. Any other internal vertex $v$ in the DFS tre, if it has a subtree rooted at a child of $v$ that does <span style=color:red>NOT</span> have an edge which climbs '*higher*' than $v$, then $v$ is an articulation point.
$d(u)$
![](15.ArticulationPoint_Observation.png)
$p=[\emptyset,1,2,3,\emptyset,5,7]$
### How to climb up
+ For an undirected graph, it can only has tree edges or back edges. A subtree can only climb to the upper part to the tree by a back tree, and a vertex can only climb up to its ancestor
![400](15.ArticulationPoints_ClimbUp.png)
--- start-multi-column

![400](15.HowClimbUp1.png)

--- end-column ---

![400](15.HowClimbUp2.png)

--- end-multi-column
### Observation 2
+ We make use of the discovery time in the DFS tree to define '$low$' and '$high$'. Observe that if we follow a path from an ancestor ($high$) to a descendant ($low$), the $\text{discovery time}$ is in $\text{increasing order}$.
+ If there vis a subtree rooted at a children of $v$ which does <span style=color:red>not</span> have a back edge connecting to a SMALLER $\text{discovery time}$ than $\text{discover}[v]$, then $v$ is an articulation point.
+ How do we know a subtree has a back edge climbing to an upper part of the tree.
+ Define $Low(v)$ to denote the earliest (highest) visited vertex (the vertex with minimum discovery time) that can be reached from the subtree rooted with v
+ $Low(v)=\text{min\{discover(v); discover(w): (u,w) is a back edge for some descendant u of v\}}$
+ w is an ancestor of v
+ u is a descendant of v
### An example $d(v)/Low(v)$
$Low(v)=\text{min\{discover(v); discover(w): (u, w)\}}$ **is a back edge for some descendant** $u$ **of** $v$
![](15.Observation_Diagram.png)
### Compute $Low(v)$
```pseudocode
procedure RDFS_Compute_Low(v)
	set visit[v] to true
	set Low[v] to discover[v] to ++time
	for each w in Adj(v) do
		if (visit[w] == False) then
			p[w] = v
			RDFS_Compute_Low(w)
			# When RDFGS_Compute_Low(w) returns, Low[w] stors the lowest value it can climb up for a subtree rooted at w.
			Low[v] = min(Low[v], Low[w])
		else if (w != p[v]) then
			# {v, w} is a back edge
			Low[v] = min(Low[v], discover[w])
		end if
	end for
end RDFS_Compute_Low
```

## An Example $d(v)/Low(v)$
![500](15.ArticulationPoints_Example3.png)
$Low(v)=min\{discover(y); discovery(w):(u,w)$ is a back age for some descendent of u of v }
## Why?
+ The identification of articulation points is important in determining the critical components of networks.
+ A component which corresponds to an articulation point is critical.
+ If such a component fails,  the network is compromised