---
type: topic
academic_year: 2
subject_code: CSCI203
subject_name: Algorithms And Data Structures
topic_number: 20
title: Huffman Trees
cssclass: flatBlue, wideTable
---
< [[__CSCI203 MOC.md|Return to CSCI203 MOC]]
## Encoding messages
+ Encode a message composed of a string of characters.
+ Codes used by computer systems
	+ ASCII
		+ Uses 8 bits per character.
		+ Can encode 256 characters.
	+ Unicode
		+ Uses 16 bits per character
		+ Can encode 65536 characters
		+ Includes all characters encoded by ASCII
+ ASCII and Unicode are fixed-length-codes
	+ All characters represented by same number of bits.
## Problems
+ Suppose that we want to encode a message constructed from the symbols A, B, C, D and E using a fixed-length code
	+ How many bits are required to encode each symbol?
		+ At least 3 bits are required.
		+ 2 bits are not enough (can only encode 4 symbols)
	+ How many bits are required to ncode the message DEAACAAAAABA?
		+ There are 12 symbols, each requires 3 bits.
		+ $12\times3=36$ bits are required.
## Drawbacks of fixed-length of codes
+ Wasted space
	+ Unicode uses twice as much space as ASCII
		+ Inefficient for plain-text messages containing only ASCII characters.
+ Same number of bits used to represent all characters.
	+ 'a' and 'e' occur more frequently than 'q' and 'z'.
+ **Potential solution**: use variable-length codes
	+ Variable number of bits to represent characters when frequency of occurrence is known.
	+ Short codes for characters that occur frequently.
## Advantages of variable-length codes
+ The advantage of variable-length codes over fixed-length
	+ Length is short codes can be given to characters that occur frequently.
	+ On average, the length of the encoded message is less than fixed-length encodign.
+ **Potential problem:** How do we know where one character ends and another begins?
	+ Not a problem if number of bits is fixed!
![300](20.VariableLengthCodes_BitsNo._Fixed.png)
## Prefix property
+ A code that has the **prefix property** if no character code is the prefix (start of the code) for another character.
+ Example:
![300](20.PrefixProperty_Example.png)
+ 000 is not a prefix of 11, 01, 001, or 10
+ 11 is not a prefix of 000, 01, 001, or 10...
### Code without prefix property
+ The following code doesn't have prefix property

| Symbol | Code |
| ------ | ---- |
| P      | 0    |
| Q      | 1    |
| R      | 01   |
| S      | 10   |
| T      | 11   |

+ The pattern **1110** can be decoded as **QQQP**, **QTP**, **QQS**, or **TS**
## Problem
+ Design a variable-length prefix-free code such that the message **DEAACAAAAABA** can be encoded using 22 bits
+ Possible solution:
	+ **A** occurs 8 times while **B, C, D** and **E** each occur once
	+ Represent **A** with a one bit code, say 0
		+ Remaining codes cannot start with 0
	+ Represent **B** with a two bit code 10
		+ Remaining codes cannot start with 0 or 10.
	+ Represent **C** with 110
	+ Represent **D** with 1110
	+ Represent **E** with 11110
### Encoded message
**DEAACAAAAABA**

| Symbol | Code  |
| ------ | ----- |
| A      | 0     |
| B      | 10    |
| C      | 110   |
| D      | 1110  |
| E      | 11110 |

<span style="border:4px solid purple">1110 11110 00 110 0000 10 0</span>

### Another possible code
**DEAACAAAAABA**

| Symbol | Code |
| ------ | ---- |
| A      | 0    |
| B      | 100  |
| C      | 101  |
| D      | 1101 |
| E      | 1111 |
<span style="border:4px solid purple; padding: 4px">1101 1111 00 101 00000 100 0</span>
### Better code
**DEAACAAAAABA**

| Symbol | Code |
| ------ | ---- |
| A      | 0    |
| B      | 100  |
| C      | 101  |
| D      | 110  |
| E      | 111  |
<span style="border: 4px solid purple; padding: 4px">110 111 00 101 00000 100 0</span>

## What code to use?
+ Question:
	+ Is there a variable-length code that makes the most efficient use of space? **Answer: Yes!**
## Huffman coding tree
+ Binary tree
	+ Each leaf contains symbol (character)
	+ Label edge from a node to its left child with 0
	+ Label edge from a node to its right child with 1
+ Code for any symbol obtained by following path from root to the leaf containing symbol.
+ Code has prefix property
	+ Leaf node cannot appear on path to another leaf.
	+ Note: Fixed-length codes are represented by a complete Huffman tree and clearly have the prefix property.
## Building a Huffman tree.
+ Find frequencies of each symbol occurring in message
+ Begin with  a forest of single node trees
	+ Each contain symbols and its frequency.
+ Do recursively.
	+ Select two trees with smallest frequency at the root.
	+ Produce a new binary tree with the selected trees as children and store the sum of their frequencies in the root.
+ Recursion ends when there is one tree.
	+ This is the Huffman coding tree
### Example
+ Build the Huffman coding tree for the message
<span style=color:red>This is his message</span>
+ Character frequencies

| Symbol | Frequencies |
| ------ | ----------- |
| A      | 1           |
| G      | 1           |
| M      | 1           |
| T      | 1           |
| E      | 2           |
| H      | 2           |
| _      | 3           |
| I      | 3           |
| S      | 5           |
+ Begin with forest of single trees
![400](20.Forest_SingleTrees.png)
### Step 1
![400](20.ConstructHuffmanTree_Step1.png)
### Step 2
![400](20.ConstructHuffmanTree_Step2.png)
### Step 3
![400](20.ConstructHuffmanTree_Step3.png)
### Step 4
![400](20.ConstructHuffmanTree_Step4.png)
### Step 5
![400](20.ConstructHuffmanTree_Step5.png)
### Step 6
![400](20.ConstructHuffmanTree_Step6.png)
### Step 7
![400](20.ConstructHuffmanTree_Step7.png)
### Step 8
![400](20.ConstructHuffmanTree_Step8.png)
### Label edges
![400](20.ConstructHuffmanTree_LabelEdges.png)

| Symbol | Code |
| ------ | ---- |
| A      | 0000 |
| G      | 0001 |
| M      | 0010 |
| T      | 0011 |
| E      | 0100 |
| H      | 0110 |
| \_     | 1000 |
| I      | 1010 |
| S      | 1100 |

## Huffman code & Encoded Message
<span style=color:red>This is his message</span>

| Symbol | Code |
| ------ | ---- |
| S      | 11   |
| E      | 010  |
| H      | 011  |
| _      | 100  |
| I      | 101  |
| A      | 0000 |
| G      | 0001 |
| M      | 0010 |
| T      | 0011 |
<span style="border: 4px solid purple; padding: 4px">00110111011110010111100011101111000010010111100000001010</span>
## Huffman code
```pseudocode
Procedure Huffman(C) 
	// C is the set of n characters and their frequencies
	set n to C.size
	set Q to priority_queue()
	for i = 1 to n do
		set n to node(C[i])
		push n onto Q
	end for
	while Q.size() is not equal to 1 do
		set Z to new node()
		set Z.left to x to Q.pop
		set Z.rigth to y to Q.pop
		Z.frequency  to x.frequency + y.frequency
		push Z onto Q
	end while
	return Q
end procedure Huffman
```
## Decompression
![](20.HuffmanTrees_Decompression.png)
```pseudocode
Procedure HuffmanDecompression(root, S)
// Root represents the root of Huffman Tree
// S refers to bit-stream to be decompressed
set n to S.length
for i = 1 to n do
	set current to root
	while current.left != NULL and current.right != NULL do
	if S[i] is equal to '0' then
		set current to current.left
	else
		set current to current.right
	end if
	set i = i + 1
end procedure HuffmanDecompression
```
## Average Bits per Symbol

| Symbol | Frequency | Probability $(p_{i})$ | Code | Code ($l_i$ bits) |
| ------ | --------- | --------------------- | ---- | ----------------- |
| A      | 1         | $\frac1{19}=0.0526$   | 0000 | 4                 |
| G      | 1         | 0.0526                | 0001 | 4                 |
| M      | 1         | 0.0526                | 0010 | 4                 |
| T      | 1         | 0.0526                | 0011 | 4                 |
| E      | 2         | 0.105                 | 0110 | 3                 |
| H      | 2         | 0.105                 | 0110 | 3                 |
| _      | 3         | 0.158                 | 0100 | 3                 |
| I      | 3         | 0.158                 | 0101 | 3                 |
| S      | 5         | 0.263                 | 0011 | 2                 |
|        | 19        | 1.0                   |      |                   |
$\text{Average bits per symbol}=\sum\limits^{9}_{i=1}p_{i}l_{i}$
