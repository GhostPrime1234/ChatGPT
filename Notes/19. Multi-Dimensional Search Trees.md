---
type: topic
academic_year: 2
subject_code: CSCI203
subject_name: Algorithms And Data Structures
topic_number: 19
title: Multi-Dimensional Search Trees
cssclass: flatBlue, wideTable
---
< [[__CSCI203 MOC.md|Return to CSCI203 MOC]]
## Query Types
+ **Exact match query:** Asks for the object(s) whose key matches query key exactly.
+ **Range query:** Asks for the objects whose key lies in a specified query range (interval)
+ **Nearest-neighbour query:** Asks for the objects whose key is "*close*" to query key.
### Exact Match Query
+ Suppose that we store employee records in a database:

| ID  | Name | Age | Salary | \#Children |
| --- | ---- | --- | ------ | ---------- |
+ Example:
	+ **key=ID**: retrieve the record with ID=1245
### Range Query
+ Example:
	+ **key=Age** retrieves all records satisfying $20<Age<50$
	+ **key=#Children:** retrieve all records satisfying $1<\#Children<4$

| ID  | Name | Age | Salary | \#Children |
| --- | ---- | --- | ------ | ---------- |
## Nearest-Neighbour(s) (NN) Query
+ Example:
	+ **key=Salary:** retrieve the employee whose salary is closest to \$50,000 (i.e., 1-NN)
	+ **key=Age:** retrieve the 5 employees whose age is closest to 40 (i.e., k-NN, k=5)

| ID  | Name | Age | Salary | \#Children |
| --- | ---- | --- | ------ | ---------- |
+ What is the closest restaurant to my hotel?
![400](19.NearestNeighboursQuery_Diagram.png)
+ Find the 4 closest restaurants to my hotel
![400](19.NearestNeighboursQuery_Diagram_4restaurents.png)
## Multi-Dimensional Query
+ In practice, queries might involve multi-dimensional keys.
	+ **key=(Name, Age):** retrieve all records with Name="*George*" and "$50\le Age\le70$"

| ID  | Name | Age | Salary | \#Children |
| --- | ---- | --- | ------ | ---------- |
## Nearest Neighbour Query in High Dimensions
+ Very important and practical problem!
	+ Image retrieval
![400](19.NearestNeighbourQuery_HighDimensions_ImageRecognition.png)
+ Face recognition
![400](19.NearestNeighbourQuery_HighDimensions_FaceRecognition.png)
## Interpreting Queries Geometrically
+ Multi-dimensional keys can be thought as "*points*" in high dimensional spaces
$\bbox[orange]{\text{Queries about records}\to\text{Queries about points}}$
### Example 1 - Range Search in 2D
A database query may ask for all employees with age between $a_{1}$ and $a_{2}$, and salary between $s_{1}$ and $s_{2}$.
![200](19.InterpretingQueriesGeometrically_RangeSearch2D.png)
$age=10,000\times+100\times\text{month + day}$
### Example 2 - Range Search in 3D
Example of a 3-dimensional (orthogonal) range query:
 children in $[2,4]$, salary in $[3000,000]$, date of birth in $[19,500,000 , 19,559,999]$
 ![400](19.InterpretingQueriesGeometrically_RangeSearch3D.png)
### Example 3 - Nearest Neighbours Search
![300](19.InterpretingQueriesGeometrically_NearestNeighbours_search.png)
## 1D Range Search
+ Data
	+ $P=\{p_{1},p_{2},\cdots,p_{n}\}$ in 1D space (a set of real numbers)
+ Query
	+ Which points are in the interval $[x,x']$
		![](19.1DRangeSearch_QueryNumberLine.png)
**Range:** $[x,x']$
<u style=color:red>Data structure 1: Sorted Array</u>
$$
A=
\begin{array}{|l|l|l|l||l|l|l|l||l|l|l|l|}
\hline
3 & 9 & 27 & 28 & 29 & 98 & 141 & 187 & 200 & 201 & 202 & 999\\
\hline
\end{array}
$$
+ <u style=color:blue>Query:</u>
		Search for x and x' in A by binary search  <span style=color:blue>O(log n)</span>
		Output all points between them.  <span style=color:blue>O(k)</span>
		Total                                              <span style=color:blue>O(log n + k)</span>
+ Example: retrieve all points in $[25, 90]$
+ Does not generalise well to high dimensions.
<u style=color:red>Data Structure 2:</u> BST
+ Search using binary search property.
+ Some subtrees are eliminated during search.
![400](19.1D_RangeSearch_BST.png)
**Example:** retrieve all points in $[25,90]$
<u style=color:red>Data Structure 3:</u> BST with data stored in leaves
+ Internal nodes store splitting values (i.e., not necessarily same as data).
+ Data points are stored in the leaf nodes
![400](19.1D_RangeSearch_BST_dataStoredLeaves.png)
### BST with data stored in leaves
![350](19.BST_dataStoredLeaves_diagram.png)
## 1D Range Search
+ Retrieving data in $[x,x']$
	+ Perform binary search twice, once using $x$ and the other user $x'$
	+ Suppose binary search ends at leaves $l$ and $l'$
	+ The points in $[x,x']$ are the ones stored between $l$ and $l'$ plus, possibly, the points stored in $l$ and $l'$.
![350](19.1D_RangeSearch_BST_dataStoredLeaves.png)
+ **Example** retrieve all parts in $[25,90]$
	+ The search path
+ How do we find the leaves of interest?
	+ Find split node (i.e., node where the paths to $x$ and $x'$ split).
	+ Left turn: report leaves in right subtrees
	+ Right turn: report leaves in left subtrees
		  $O(\log n+k)$ time where k is the number of items reported
  + Speed-up search by keeping the leaves in sorted order using a linked list
## 2D Range Search
+ A 2D range query asks for the points inside a query rectangle $[x,x']\times[y,y']$
+ A point $(p_{x},p_{y})$ lies in this rectangle if and only if: $p_{x}\in[x,x']\quad and\ p_{y}\in[y,y']$
![300](19.2D_Range_Search_QueryPoint.png)
+ A 2D range query can be decomposed in two 1D range queries:
	+ One on the x-coordinate of the points.
	+ The other on the y-coordinates of the points
+ Store a **primary 1D range tree** for all the points based on x-coordinate.
+ For each node, store a **secondary 1D range tree** based on y-coordinate
+ Search using the x-coordinate only.
+ How to restrict to points with proper y-coordinate?
	+ Recursively search within each subset using the y-coordinate.
	+ Query cost: $O(\log^{2}n+k)$
## Range Search in dimensions
**1D query time:** $O(\log n+k)$
**2D query time:** $O(\log^{2}n+k)$
**d dimensions:**
**Query time:  $O(k)+\log^{d}n$ to report $k$ points.**
**Space: $O(n\log^{d-1}n)$**
## KD Tree
+ A binary search tree where every node is a k-dimensional point.
+ Example: k=2
![450](19.KD_Tree_k=2_Example.png)
**Example:** data stored at the leaves
![400](19.KD_Tree_dataStoredLeaves.png)
+ Every node (except leaves) represents a hyperplane that divides the space into two parts.
+ Points to the left (right) of this hyperplane represent the left (right) sub-tree of that node
![200](19.KD_Tree_Hyperplane.png)
As we move down the tree, we <span style=color:red><b>alternating</b></span> (but not always) axis-aligned hyperplanes:
+ <u>Split by x-coordinate:</u> split by a vertical line that has (ideally) half the points left or on, and half right.
+ <u>Split by y-coordinate:</u> split by a horizontal line that has (ideally) half the points below or on and half above.
### KD Tree - Example
<u>Split by x-coordinate:</u> Split by a vertical line that has approximately half the points left or on, and half right.
![400](19.KD_Tree_example1.png)
<u>Split by y-coordinate:</u> Split by a horizontal line that has half the points below or on and half above.
![400](19.KD_Tree_example2.png)
<u>Split by x-coordinate:</u> Split by a vertical line that has approximately half the points left or on, and half right.
![400](19.KD_Tree_example1-2.png)

<u>Split by y-coordinate:</u> Split by a horizontal line that has half the points below or on and half above.
![400](19.KD_Tree_example2-2.png)
### Insert new data
`Insert(55, 62)`
![500](19.KD_Tree_InsertNewData.png)
### Delete data
+ Suppose we need to remove $p=(a,b)$
	+ Find node $t$ which contains $p$
	+ If $t$ is a leaf node, replace it by null.
	+ Otherwise, find a replacement node $r=(c,d)$ - see below!
	+ Replace $(a,c)\text{ by }(c,d)$
	+ Remove $r$
+ Finding the replacement $r=(c,d)$
	+ If $t$ has a right child, use the $successor*$
	+ Otherwise, use node with minimum $value*$ in the left subtree
+ How to find the replacement for $(c,d)$ for $(a,b)$?
	+ \*(depending on what axis the node discriminates)
+ 2. Else If node to be deleted has left child as not NULL
	1. Find minimum of current node's dimension in left subtree
	2. Replace the node with above found minimum and recursively delete minimum in left subtree.
	3. Make left subtree as right child of current node.
![400](19.DeleteData.png)
### KD Tree - Exact Search
![400](19.KD_Tree_ExactSearch_Key-Age.png)
<span style=color:red>Search key: (32, P)</span>
![400](19.KD_Tree_ExactSearch_Key-Name.png)
<span style=color:red>Search key: (32, P)</span>
### KD Tree - Complexity
+ Construction $O(dn\log n)$
	+ Sort points in each dimension: $O(dn\log n)$
	+ Determine splitting line (median finding): $O(dn)$
+ Space requirements:
	+ $O(n)$
+ Query requirements:
	+ KD tree: $O(n^{\frac{1-1}{d}}+k)\to O(n+k)\text{ as }d$ increases!
## Node Structure
+ A KD-tree node has 5 fields.
	+ Splitting axis
	+ Splitting value
	+ Data
	+ Left pointer
	+ Right pointer
### Splitting Strategies
+ Divide based on order of point insertion
	+ Assumes that points are given one at a time.
+ Divide by finding median
	+ Assumes all points are available ahead of time.
+ Divide perpendicular to the axis with wides spread.
	+ Split axes might not alternate.
## Example - Using order of point insertion (data stored at nodes)

![400](19.KD_Tree-OrderPointsInsertion.png)