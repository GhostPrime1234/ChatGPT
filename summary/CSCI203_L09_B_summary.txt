# A* Algorithm and Dijkstra's Algorithm Notes

## Overview of Pathfinding Algorithms
### Introduction
- Pathfinding algorithms are essential in computer science for navigating graphs and grids.
- Two prominent algorithms used for finding the shortest path are Dijkstra's Algorithm and the A* Algorithm.

## Dijkstra's Algorithm
### Description
- Dijkstra's Algorithm is designed to find the shortest paths from a starting vertex to all other vertices in a weighted graph.
- It guarantees finding the shortest path but can be inefficient in terms of speed when dealing with single-source to single-destination problems.

### Procedure
```plaintext
Procedure Dijkstra(G: array[1..n, 1..n]): array[2..n]
    D: array[2..n], P: array[2..n]
    C: set = {2, 3, .., n}
    for i = 2 to n do
        D[i] = G[1, i]
        P[i] = 1
    od
    repeat
        v = the index of the minimum D[v] not yet selected
        remove v from C // and implicitly add v to S
        for each u in C do
            D[u] = min(D[u], D[v] + G[v, u])
            P[u] = v
        od
    until C contains no reachable nodes
    return D
end Dijkstra
```

### Limitations
- The algorithm examines vertices based on their proximity to the starting point rather than the goal, which can lead to inefficiency when searching for a specific destination.

## A* Algorithm
### Description
- The A* Algorithm improves upon Dijkstra's by combining its mechanics with heuristics, allowing it to efficiently find the shortest path from a starting vertex to a goal vertex.
- It uses a heuristic function to estimate the cost from the current vertex to the goal, thus guiding the search more effectively.

### Heuristic Function
- The A* algorithm selects vertices based on the function:
  \[
  f(v) = g(v) + h(v)
  \]
  Where:
  - \( g(v) \) is the cost from the starting vertex to vertex \( v \).
  - \( h(v) \) is the estimated cost from vertex \( v \) to the goal vertex.

### Properties of a Good Heuristic
- The heuristic must not overestimate the actual shortest path:
  \[
  h(v, g) \leq P(v, g)
  \]
  This ensures that the algorithm remains optimal.

### Examples of Heuristics
1. **Euclidean Distance**:
   - Suitable for scenarios where movement is allowed in any direction.
   - Formula:
   \[
   h = \sqrt{(current\_cell.x - goal.x)^2 + (current\_cell.y - goal.y)^2}
   \]

2. **Manhattan Distance**:
   - Used when movement is restricted to horizontal and vertical directions only.
   - Formula:
   \[
   h = |current\_cell.x - goal.x| + |current\_cell.y - goal.y|
   \]

### Efficiency Improvements
- A* can be made more efficient by using a priority queue (or heap) to manage the candidate vertices, thus improving the overall complexity to:
  \[
  O(|V| \log |V| + |E|)
  \]

### Algorithm Steps
```plaintext
1. Initialize the open list (nodes to be explored).
2. Initialize the closed list (nodes already explored).
3. While the open list is not empty:
    a) Find the node with the least f in the open list, call it "q".
    b) Remove q from the open list.
    c) Generate q's non-blocked successors and set their parents to q.
    d) For each successor:
        i) If it is the goal, stop the search.
        ii) Calculate g, h, and f values for successors.
        iii) Add successors to the open list if they are not already present with a lower f value.
    e) Push q onto the closed list.
```

## Comparing A* and Dijkstra's Algorithm
### Similarities
- Both algorithms are used for pathfinding in graphs.
- A* can be viewed as a generalization of Dijkstra's algorithm, where Dijkstra's is a special case with \( h(v, g) = 0 \).

### Differences
- A* is typically faster due to its heuristic guidance, while Dijkstra's can be more exhaustive.
- A* is more suitable for single-source to single-destination problems, whereas Dijkstra's is designed for single-source to all destinations.

## Conclusion
- The A* algorithm offers a balanced approach by combining the reliability of Dijkstra's algorithm with the speed of greedy algorithms through the use of heuristics.
- Selecting an appropriate heuristic is crucial for maximizing the efficiency of the A* algorithm.