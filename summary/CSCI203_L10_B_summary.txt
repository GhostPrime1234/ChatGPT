# Dynamic Programming in Algorithms and Data Structures

## Overview
Dynamic Programming (DP) is a method for solving complex problems by breaking them down into simpler subproblems. It is particularly useful for optimization problems. This lecture, delivered by Dr. Xueqiao Liu, covers the fundamentals of dynamic programming, including naive recursive algorithms, memoization, and specific applications such as the Rod Cutting Problem and the Coin-Collection Problem.

---

## Step 1: The Naive, Recursive Algorithm

### Key Components of Dynamic Programming
- **Recursion**: The naive approach often relies on recursive methods to explore all possible solutions.
- **Memoization**: To improve efficiency, previously computed results are stored, preventing redundant calculations.
- **Guessing**: The algorithm may need to "guess" the optimal solution by trying various possibilities.

### Example: Rod Cutting Problem
- A rod of length `n` can be cut in `2^(n-1)` ways.
- For `n = 4`, different cutting combinations can yield different revenues.
- The goal is to find the optimal revenue by choosing the best cutting strategy.

---

## Coin-Collection Problem

### Problem Definition
- A robot starts at the top left of an `n x m` board and can move right or down to collect coins placed in the cells.
- The task is to find the maximum number of coins the robot can collect when it reaches the bottom right cell.

### Dynamic Programming Approach
1. **State Definition**: Let `F(i, j)` be the maximum coins collected to cell `(i, j)`.
2. **Recurrence Relation**:
   \[
   F(i, j) = \max(F(i-1, j), F(i, j-1)) + C[i, j]
   \]
   Where `C[i, j]` is `1` if there is a coin in cell `(i, j)` and `0` otherwise.

### Algorithm Implementation
```python
def max_coins(C):
    n = len(C)
    m = len(C[0])
    F = [[0] * m for _ in range(n)]
    
    F[0][0] = C[0][0]  # Starting point
    for j in range(1, m):
        F[0][j] = F[0][j-1] + C[0][j]
    for i in range(1, n):
        F[i][0] = F[i-1][0] + C[i][0]
    for i in range(1, n):
        for j in range(1, m):
            F[i][j] = max(F[i-1][j], F[i][j-1]) + C[i][j]
    
    return F[n-1][m-1]
```

### Analysis
- The algorithm efficiently computes the maximum coins using a 2D array to store results, leading to a time complexity of \(O(n \times m)\).

---

## Dynamic Programming for Optimal Rod-Cutting

### Problem Definition
- Given a rod of length `n` and a price table `p` for lengths `1` to `n`, determine the maximum revenue obtainable by cutting the rod.

### Top-Down Recursive Algorithm
```python
def memoized_cut_rod(p, n, r):
    if r[n] >= 0:
        return r[n]
    if n == 0:
        q = 0
    else:
        q = float('-inf')
        for i in range(1, n + 1):
            q = max(q, p[i] + memoized_cut_rod(p, n - i, r))
    r[n] = q
    return q
```

### Bottom-Up Approach
```python
def bottom_up_cut_rod(p, n):
    r = [0] * (n + 1)
    for j in range(1, n + 1):
        q = float('-inf')
        for i in range(1, j + 1):
            q = max(q, p[i] + r[j - i])
        r[j] = q
    return r[n]
```

### Revenue Calculation
- The maximum revenue can be computed by considering all possible cuts and choosing the one that maximizes revenue.

---

## Analysis of Algorithms

### Complexity
- **Top-Down Approach**: \(O(n^2)\) due to the recursive calls.
- **Bottom-Up Approach**: \(O(n^2)\) as well, but more efficient in practice since it avoids the overhead of recursion.

### Solution Reconstruction
- To reconstruct the solution, keep track of the cuts made during the computation which can be stored in an auxiliary array.

```python
def extended_bottom_up_cut_rod(p, n):
    r = [0] * (n + 1)
    s = [0] * (n + 1)
    for j in range(1, n + 1):
        q = float('-inf')
        for i in range(1, j + 1):
            if q < p[i] + r[j - i]:
                q = p[i] + r[j - i]
                s[j] = i
        r[j] = q
    return r, s
```

### Example of Solution Reconstruction
- Using the `s` array from the extended function, we can print the sizes of the pieces cut.

---

## Related References
- **Books**:
  - "Introduction to the Design and Analysis of Algorithms" by A. Levitin
  - "Introduction to Algorithms" by T.H. Cormen

---

These notes encapsulate the key concepts and examples from the lecture on dynamic programming, providing a structured overview of the subject matter.