# Big Numbers

## Overview
Big numbers, or integers larger than typical data types can be crucial in various computing applications, including cryptography and arbitrary precision arithmetic. This lecture covers the representation, addition, multiplication, and exponentiation of large numbers.

## Representation of Large Numbers
### Base Representation
- **Definition**: Large integers can be represented in various bases.
- **Examples**:
  - Base 10: \( 123456 = 1 \times 10^5 + 2 \times 10^4 + 3 \times 10^3 + 4 \times 10^2 + 5 \times 10^1 + 6 \times 10^0 \)
  - Base 2: \( 100000000000000000000 \) (binary representation)
  - Base 3: \( 1222021101011 \)
  - Base 5: \( 232023301 \)
  - Base 7: \( 11625034 \)

### Chunk Representation
- **Strategy**: Break large numbers into manageable chunks fitting within a computer word.
- **Example**: A 1024-bit number can be represented as:
  - 32 chunks of 32-bit integers
  - 16 chunks of 64-bit integers

### Decimal Notation
- **Concept**: Each digit in decimal notation represents a chunk in a sequence of powers of ten. For example, \( 27^0 = 1048576 \).

## Addition of Large Numbers
### Chunk-Based Addition
- **Formulation**:
  - Let \( x \) and \( y \) be large integers expressed in base \( b \):
    - \( x = x_k b^k + x_{k-1} b^{k-1} + \ldots + x_0 b^0 \)
    - \( y = y_k b^k + y_{k-1} b^{k-1} + \ldots + y_0 b^0 \)
  - The sum is:
    - \( x + y = (x_k + y_k) b^k + (x_{k-1} + y_{k-1}) b^{k-1} + \ldots + (x_0 + y_0) b^0 \)

### Efficiency
- Adding two \( k \)-chunk integers involves \( k \) additions of \( b \)-digit integers, yielding a time complexity of \( O(k) \).

## Multiplication of Large Numbers
### Chunk-Based Multiplication
- **Formulation**:
  - To multiply \( x \) and \( y \):
    - \( xy = (x_k b^k + x_{k-1} b^{k-1} + \ldots + x_0)(y_k b^k + y_{k-1} b^{k-1} + \ldots + y_0) \)
  - Requires calculating products for all pair combinations, leading to:
    - \( O(n^2) \) multiplications if each number has \( n \) digits.

### Karatsuba Multiplication
- **Optimization**: Uses divide-and-conquer strategy to reduce multiplications.
- **Steps**:
  - Split numbers into two halves:
    - \( x = x_1 b^m + x_0 \)
    - \( y = y_1 b^m + y_0 \)
  - Calculate:
    - \( z_0 = x_0 \times y_0 \)
    - \( z_1 = (x_1 + x_0)(y_1 + y_0) - z_0 - z_1 \)
    - \( z_2 = x_1 \times y_1 \)
  - Combine: \( xy = z_2 b^{2m} + z_1 b^m + z_0 \)
- **Complexity**: Reduces time complexity to \( O(n^{\log_2 3}) \approx O(n^{1.585}) \).

## Fast Exponentiation
### Recursive Method
- **Formula**:
  - For exponentiation \( x^y \):
    - If \( y \) is even: \( x^y = (x^{y/2})^2 \)
    - If \( y \) is odd: \( x^y = x \times x^{y-1} \)

### Iterative Method
- **Procedure**:
```python
def fast_power_iter(x, y):
    result = 1
    a = x
    while y > 0:
        if y % 2 == 1:  # If y is odd
            result = big_mult(result, a)
        a = big_mult(a, a)  # Square a
        y //= 2  # Divide y by 2
    return result
```
- **Efficiency**: Reduces the number of multiplications to \( O(\log y) \).

## Modular Powers
### Concept
- **Modular Arithmetic**: Useful when results need to be computed modulo \( m \).
- **Formula**:
```python
def mod_power(x, y, m):
    result = 1
    a = x % m
    while y > 0:
        if y % 2 == 1:
            result = (result * a) % m
        a = (a * a) % m
        y //= 2
    return result
```

## Conclusion
Efficient computation of big numbers is essential in various fields, especially in cryptography and data processing. Techniques such as chunk representation, Karatsuba multiplication, and fast exponentiation significantly enhance performance. Understanding the underlying principles of these methods is crucial for practical applications.